// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GLib {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Mutex : GLib.Opaque {
		public struct ABI {
			IntPtr p;
			int i1;
			int i2;
		}
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		delegate void d_g_mutex_clear(IntPtr raw);
		static d_g_mutex_clear g_mutex_clear = FuncLoader.LoadFunction<d_g_mutex_clear>(FuncLoader.GetProcAddress(GLibrary.Load(Library.GLib), "g_mutex_clear"));

		public void Clear() {
			g_mutex_clear(Handle);
		}
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		delegate void d_g_mutex_init(IntPtr raw);
		static d_g_mutex_init g_mutex_init = FuncLoader.LoadFunction<d_g_mutex_init>(FuncLoader.GetProcAddress(GLibrary.Load(Library.GLib), "g_mutex_init"));

		public void Init() {
			g_mutex_init(Handle);
		}
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		delegate void d_g_mutex_lock(IntPtr raw);
		static d_g_mutex_lock g_mutex_lock = FuncLoader.LoadFunction<d_g_mutex_lock>(FuncLoader.GetProcAddress(GLibrary.Load(Library.GLib), "g_mutex_lock"));

		public void Lock() {
			g_mutex_lock(Handle);
		}
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		delegate bool d_g_mutex_trylock(IntPtr raw);
		static d_g_mutex_trylock g_mutex_trylock = FuncLoader.LoadFunction<d_g_mutex_trylock>(FuncLoader.GetProcAddress(GLibrary.Load(Library.GLib), "g_mutex_trylock"));

		public bool Trylock() {
			bool raw_ret = g_mutex_trylock(Handle);
			bool ret = raw_ret;
			return ret;
		}
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		delegate void d_g_mutex_unlock(IntPtr raw);
		static d_g_mutex_unlock g_mutex_unlock = FuncLoader.LoadFunction<d_g_mutex_unlock>(FuncLoader.GetProcAddress(GLibrary.Load(Library.GLib), "g_mutex_unlock"));

		public void Unlock() {
			g_mutex_unlock(Handle);
		}

		public Mutex(IntPtr raw) : base(raw) {}

#endregion
	}
}

