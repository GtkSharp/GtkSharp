<Type Name="TextBuffer" FullName="Gtk.TextBuffer">
  <TypeSignature Language="C#" Maintainer="duncan" Value="public class TextBuffer : GLib.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextBuffer extends GLib.Object" />
  <AssemblyInfo>
    <AssemblyName>gtk-sharp</AssemblyName>
    <AssemblyPublicKey>
    </AssemblyPublicKey>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>GLib.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <summary>This class stores formatted text for display in a <see cref="T:Gtk.TextView" />.
    </summary>
    <remarks>
      <para>The relationship between <see cref="T:Gtk.TextBuffer" /> and <see cref="T:Gtk.TextView" /> objects is not necessarily one-to-one. All views must contain a buffer, but a buffer does not have to be assigned a view, and one buffer may be used by multiple views.</para>
      <example>
        <para>In the following example, a single <see cref="T:Gtk.TextBuffer" /> object is shared between two <see cref="T:Gtk.TextView" /> widgets.</para>
        <code lang="C#">using Gtk;

public class TextBufferExample
{
	public static void Main ()
	{
		// Initialize GTK.
		Application.Init ();
		
		// Create a containing window.
		Window window = new Window ("TextBuffer Example");
		window.DeleteEvent += OnDelete;
		window.SetDefaultSize (400, 300);
		
		// Create a buffer and vertical panes for the views.
		TextBuffer buffer = new TextBuffer (new TextTagTable ());
		VPaned paned = new VPaned ();
		
		// Create a text view for the buffer, make it scrollable, and
		// add it to the first pane.
		TextView view1 = new TextView (buffer);
		ScrolledWindow scrolled_window1 = new ScrolledWindow ();
		scrolled_window1.Add (view1);
		paned.Add1 (scrolled_window1);
		
		// Create a second text view for the buffer, make it scrollable,
		// and add it to the second pane.
		TextView view2 = new TextView (buffer);
		ScrolledWindow scrolled_window2 = new ScrolledWindow ();
		scrolled_window2.Add (view2);
		paned.Add2 (scrolled_window2);
		
		// Add the panes to the window and show it.
		window.Add (paned);
		window.ShowAll ();
		
		// Run the application.
		Application.Run ();
	}
	
	// Quit when the window is closed.
	static void OnDelete (object o, DeleteEventArgs e)
	{
		Application.Quit ();
	}
}</code>
      </example>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBuffer (Gtk.TextTagTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Gtk.TextTagTable table) cil managed" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="table" Type="Gtk.TextTagTable" />
      </Parameters>
      <Docs>
        <param name="table">a tag table, or <see langword="null" /> to create a new one</param>
        <summary>Creates a new text buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBuffer (IntPtr raw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int raw) cil managed" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="raw" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="raw">Pointer to the C object.</param>
        <summary>Internal constructor</summary>
        <remarks>
          <para>This is an internal constructor, and should not be used by user code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMark">
      <MemberSignature Language="C#" Value="public void AddMark (Gtk.TextMark mark, Gtk.TextIter wh3r3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMark(class Gtk.TextMark mark, valuetype Gtk.TextIter wh3r3) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
        <Parameter Name="wh3r3" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="mark">To be added.</param>
        <param name="wh3r3">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version="Gtk# 2.12" />
      </Docs>
    </Member>
    <Member MemberName="AddSelectionClipboard">
      <MemberSignature Language="C#" Value="public void AddSelectionClipboard (Gtk.Clipboard clipboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddSelectionClipboard(class Gtk.Clipboard clipboard) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <param name="clipboard">an object of type <see cref="T:Gtk.Clipboard" /></param>
        <summary>Adds <paramref name="clipboard" /> to the list of clipboards in which the selection contents of buffer are available.</summary>
        <remarks>In most cases, clipboard will be the <see cref="T:Gtk.Clipboard" /> of type <see cref="F:Gdk.Selection.Primary" /> for a view of buffer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyTag">
      <MemberSignature Language="C#" Value="public void ApplyTag (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyTag(class Gtk.TextTag tag, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="tag">a <see cref="Gtk.TextTag" /></param>
        <param name="start">the beginning of the range to be tagged</param>
        <param name="end">the end of the range to be tagged</param>
        <summary>Fires the <see cref="E:Gtk.TextBuffer.ApplyTag" /> events on buffer.</summary>
        <remarks>
          <para>
            The default handler for the signal applies tag to the
            given range. <paramref name="start" /> and <paramref name="end" /> do not have to be in order.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyTag">
      <MemberSignature Language="C#" Value="public void ApplyTag (string name, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyTag(string name, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="name">the name of the tag</param>
        <param name="start">the location of the beginning of the range</param>
        <param name="end">the location of the end of the range</param>
        <summary>
          Fires the <see cref="E:Gtk.TextBuffer.TagApplied" /> event on buffer. The default handler
          for the signal applies tag to the given range.
        </summary>
        <remarks>
          <para>
            The order for <paramref name="start" /> and <paramref name="end" /> is not important.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public bool Backspace (ref Gtk.TextIter iter, bool interactive, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Backspace(valuetype Gtk.TextIter iter, bool interactive, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="interactive" Type="System.Boolean" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="iter">a <see cref="T:Gtk.TextIter" /></param>
        <param name="interactive">a <see cref="T:System.Boolean" /></param>
        <param name="default_editable">a <see cref="T:System.Boolean" /></param>
        <summary>To be added</summary>
        <returns>a <see cref="T:System.Boolean" /></returns>
        <remarks>To be added</remarks>
        <since version="Gtk# 2.6" />
      </Docs>
    </Member>
    <Member MemberName="BeginUserAction">
      <MemberSignature Language="C#" Value="public void BeginUserAction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginUserAction() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called to indicate that the buffer operations between here and a call to <see cref="M:Gtk.TextBuffer.EndUserAction()" /> are part of a single user-visible operation.</summary>
        <remarks>
          <para>The operations between <see cref="M:Gtk.TextBuffer.BeginUserAction()" /> and <see cref="M:Gtk.TextBuffer.EndUserAction()" /> can then be grouped when creating an undo stack. <see cref="T:Gtk.TextBuffer" /> maintains a count of calls to <see cref="M:Gtk.TextBuffer.BeginUserAction()" /> that have not been closed with a call to <see cref="M:Gtk.TextBuffer.EndUserAction()" />, and emits <see cref="E:Gtk.TextBuffer.UserActionBegun" /> and <see cref="E:Gtk.TextBuffer.UserActionEnded" /> signals only for the outermost pair of calls. This allows you to build user actions from other user actions.
</para>
          <para>The "interactive" buffer mutation functions, such as <see cref="M:Gtk.TextBuffer.InsertInteractive()" />, automatically call begin/end user action around the buffer operations they perform, so there is no need to add extra calls if you user action consists solely of a single call to one of those functions.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when the text in the buffer has been changed.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="CharCount">
      <MemberSignature Language="C#" Value="public int CharCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CharCount" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of characters in the buffer</summary>
        <value>The number of characters in the buffer</value>
        <remarks>
          <para>The result of this method is cached, so it is very fast.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildAnchorInserted">
      <MemberSignature Language="C#" Value="public event Gtk.ChildAnchorInsertedHandler ChildAnchorInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.ChildAnchorInsertedHandler ChildAnchorInserted" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("insert-child-anchor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.ChildAnchorInsertedHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a ChildAnchor has been inserted in the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the contents of the buffer</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyClipboard">
      <MemberSignature Language="C#" Value="public void CopyClipboard (Gtk.Clipboard clipboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyClipboard(class Gtk.Clipboard clipboard) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <param name="clipboard">The <see cref="T:Gtk.Clipboard" /> to copy the text to.</param>
        <summary>Copies the buffer's selected text to the given <see cref="T:Gtk.Clipboard" />.</summary>
        <remarks>
          <para>Copying a <see cref="T:Gtk.TextView" />'s selected text:</para>
          <example>
            <code lang="C#"> void Copy (Gtk.TextView view) {
	Gtk.TextBuffer buffer = view.Buffer;
	Gtk.Clipboard board = Clipboard.Get (Gdk.Selection.Clipboard);
	buffer.CopyClipboard (board);
} </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTargetList">
      <MemberSignature Language="C#" Value="public Gtk.TargetList CopyTargetList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gtk.TargetList CopyTargetList" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("copy-target-list")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.TargetList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the copy TargetList.</summary>
        <value>a <see cref="T:Gtk.TargetList" />.</value>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildAnchor">
      <MemberSignature Language="C#" Value="public Gtk.TextChildAnchor CreateChildAnchor (ref Gtk.TextIter iter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gtk.TextChildAnchor CreateChildAnchor(valuetype Gtk.TextIter iter) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextChildAnchor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="iter">the location in the buffer</param>
        <summary>
          This is a convenience function which simply creates a child
          anchor with <see cref="C:Gtk.TextChildAnchor" /> and inserts it into
          the buffer with <see cref="M:Gtk.TextBuffer.InsertChildAnchor(Gtk.TextIter,Gtk.TextChildAnchor)" />.
        </summary>
        <returns>the created child anchor</returns>
        <remarks>
          <para>
          This is a convenience function which simply creates a child
          anchor with <see cref="C:Gtk.TextChildAnchor" /> and inserts it into
          the buffer with <see cref="M:Gtk.TextBuffer.InsertChildAnchor(Gtk.TextIter,Gtk.TextChildAnchor)" />. The new anchor is owned by the buffer; no reference
          count is returned to the caller of <see cref="M:Gtk.TextBuffer.CreateChildAnchor(Gtk.TextIter)" />.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="CreateMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark CreateMark (string mark_name, Gtk.TextIter wh3r3, bool left_gravity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gtk.TextMark CreateMark(string mark_name, valuetype Gtk.TextIter wh3r3, bool left_gravity) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark_name" Type="System.String" />
        <Parameter Name="wh3r3" Type="Gtk.TextIter" />
        <Parameter Name="left_gravity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mark_name">name for mark, or <see langword="null" />.</param>
        <param name="wh3r3">To be added.</param>
        <param name="left_gravity">whether the mark has left gravity</param>
        <summary>Creates a mark at position <paramref name="where" />.</summary>
        <returns>a new <see cref="T:Gtk.TextMark" /> object</returns>
        <remarks>
          <para>
            Creates a mark at position <paramref name="where" />. If <paramref name="mark_name" /> is <see langword="null" />,
            the mark is anonymous; otherwise, the mark can be
            retrieved by name using <see cref="Gtk.TextBuffer.GetMark(System.String)" />. If a
            mark has left gravity, and text is inserted at the
            current location of the mark, the mark will be moved to the left of
            the newly-inserted text. If the mark has right gravity
            (ie. <paramref name="left_gravity" /> = <see langword="false" />), the mark will end up on the right
            of newly-inserted text. The standard left-to-right cursor
            is a mark with right gravity (when you type, the cursor
            stays on the right side of the text you are typing).
          </para>
          <para>
            Fires the <see cref="E:Gtk.TextBuffer.MarkSet" /> event as
            notification of the initial placement of the mark.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CursorPosition">
      <MemberSignature Language="C#" Value="public int CursorPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CursorPosition" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("cursor-position")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Position of the insert mark.</summary>
        <value>a <see cref="T:System.Int32" /> representing the offset to the cursor from the beginning of the buffer.</value>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="CutClipboard">
      <MemberSignature Language="C#" Value="public void CutClipboard (Gtk.Clipboard clipboard, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CutClipboard(class Gtk.Clipboard clipboard, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clipboard">an object of type <see cref="T:Gtk.Clipboard" /></param>
        <param name="default_editable">an object of type <see cref="T:System.Boolean" /></param>
        <summary>Copies the currently-selected text to a clipboard, then deletes said text if it is editable.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by 'ref TextIter, ref TextIter' overload")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="start">To be added.</param>
        <param name="end">To be added.</param>
        <summary>Delete text between two iterators.</summary>
        <remarks>This overload is obsolete, replaced by ref TextIter overloads since the iters passed in are updated by the caller.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (ref Gtk.TextIter start, ref Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="end" Type="Gtk.TextIter&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="start">a position in the buffer</param>
        <param name="end">a position in the buffer</param>
        <summary>
          Deletes text between <paramref name="start" /> and <paramref name="end" />.
        </summary>
        <remarks>
          <para>
            Deletes text between <paramref name="start" /> and <paramref name="end" />. The order of the two is not actually
            relevant, as they will be reordered. This function
            actually fires off  the <see cref="E:Gtk.TextBuffer.DeleteRange" /> event, and the default
            handler of that signal deletes the text. Because the
            buffer is modified, all outstanding iterators become
            invalid after calling this function; however, <paramref name="start" />
            and <paramref name="end" /> will be re-initialized to point to the location
            where text was deleted.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="DeleteInteractive">
      <MemberSignature Language="C#" Value="public bool DeleteInteractive (ref Gtk.TextIter start_iter, ref Gtk.TextIter end_iter, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DeleteInteractive(valuetype Gtk.TextIter start_iter, valuetype Gtk.TextIter end_iter, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start_iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="end_iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="start_iter">the beginning of range to delete</param>
        <param name="end_iter">the end of the range to delete</param>
        <param name="default_editable">whether the buffer is editable by default</param>
        <summary>Deletes all editable text in the given range.</summary>
        <returns>whether some text was actually deleted</returns>
        <remarks>
          <para>
            Deletes all editable text in the given range. Calls <see cref="M:Gtk.TextBuffer.Delete(Gtk.TextIter,Gtk.TextIter)" /> for each editable sub-range of <paramref name="start" />
            and <paramref name="end" />. <paramref name="start" /> and
            <paramref name="end" /> are revalidated to point to the
            location of the last deleted range, or left untouched if
            no text was deleted.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="DeleteMark">
      <MemberSignature Language="C#" Value="public void DeleteMark (Gtk.TextMark mark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteMark(class Gtk.TextMark mark) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <param name="mark">
          a <see cref="T:Gtk.TextMark" /> in the buffer to be deleted.
        </param>
        <summary>Deletes mark, so that it is no longer located anywhere in the buffer.</summary>
        <remarks>
          <para>
            Deletes mark, so that it is no longer located anywhere in
            the buffer.  There is no way to undelete a
            mark. <see cref="P:Gtk.TextMark.Deleted" /> will return
            <see langword="true" /> after
            this function has been called on a mark;
            <see cref="P:Gtk.TextMark.Deleted" /> indicates that a mark no
            longer belongs to a buffer. The <see cref="E:Gtk.TextBuffer.MarkDeleted" /> event will
            be raised as notification after the mark is deleted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteMark">
      <MemberSignature Language="C#" Value="public void DeleteMark (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteMark(string name) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">the name of a mark in buffer</param>
        <summary>Deletes the mark named <paramref name="name" />; the mark must exist.</summary>
        <remarks>
          <para>
            See <see cref="M:Gtk.TextBuffer.DeleteMark(Gtk.TextMark)" />  for more details.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRange">
      <MemberSignature Language="C#" Value="public event Gtk.DeleteRangeHandler DeleteRange;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.DeleteRangeHandler DeleteRange" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("delete-range")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.DeleteRangeHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a range of text has been deleted from the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="DeleteSelection">
      <MemberSignature Language="C#" Value="public bool DeleteSelection (bool interactive, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DeleteSelection(bool interactive, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interactive" Type="System.Boolean" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="interactive">whether the deletion is caused by user interaction</param>
        <param name="default_editable">whether the buffer is editable by default</param>
        <summary>Deletes the currently-selected text</summary>
        <returns>
           whether there was a non-empty selection to delete
        </returns>
        <remarks>
          <para>
            Deletes the range between the "insert" and
            "selection_bound" marks, that is, the currently-selected
            text. If <paramref name="interactive" /> is <see langword="true" />, the editability of the selection will
            be considered (users can't delete uneditable text).
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public bool Deserialize (Gtk.TextBuffer content_buffer, Gdk.Atom format, ref Gtk.TextIter iter, byte[] data, ulong length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Deserialize(class Gtk.TextBuffer content_buffer, class Gdk.Atom format, valuetype Gtk.TextIter iter, unsigned int8[] data, unsigned int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content_buffer" Type="Gtk.TextBuffer" />
        <Parameter Name="format" Type="Gdk.Atom" />
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="length" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="content_buffer">buffer to deserialize content.</param>
        <param name="format">MIME type format.</param>
        <param name="iter">insertion point.</param>
        <param name="data">serialized data.</param>
        <param name="length">length of serialized data.</param>
        <summary>Deserialize content.</summary>
        <returns>a <see cref="T:System.Boolean" />.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="DeserializeFormats">
      <MemberSignature Language="C#" Value="public Gdk.Atom[] DeserializeFormats { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gdk.Atom[] DeserializeFormats" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The supported MIME type formats for deserialization.</summary>
        <value>an array of MIME type Atoms.</value>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="DeserializeGetCanCreateTags">
      <MemberSignature Language="C#" Value="public bool DeserializeGetCanCreateTags (Gdk.Atom format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DeserializeGetCanCreateTags(class Gdk.Atom format) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="Gdk.Atom" />
      </Parameters>
      <Docs>
        <param name="format">a MIME type Atom.</param>
        <summary>Determines if tag creation is supported for a MIME type deserializer.</summary>
        <returns>if <see langword="true" />, tag creation is supported.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="DeserializeSetCanCreateTags">
      <MemberSignature Language="C#" Value="public void DeserializeSetCanCreateTags (Gdk.Atom format, bool can_create_tags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeserializeSetCanCreateTags(class Gdk.Atom format, bool can_create_tags) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="Gdk.Atom" />
        <Parameter Name="can_create_tags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="format">a MIME type Atom.</param>
        <param name="can_create_tags">a <see cref="T:System.Boolean" />.</param>
        <summary>Enables or disables arbitrary tag creation.</summary>
        <remarks>In most cases, you don't want to do this, as it will put arbitrary tags in the buffer.</remarks>
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="EndIter">
      <MemberSignature Language="C#" Value="public Gtk.TextIter EndIter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Gtk.TextIter EndIter" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The end of the buffer</summary>
        <value>The location of the end of the buffer</value>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="EndUserAction">
      <MemberSignature Language="C#" Value="public void EndUserAction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUserAction() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Should be paired with a call to <see cref="M:Gtk.TextBuffer.BeginUserAction()" />.</summary>
        <remarks>See <see cref="M:Gtk.TextBuffer.BeginUserAction()" /> for an explanation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public void GetBounds (out Gtk.TextIter start, out Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetBounds(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter&amp;" RefType="out" />
        <Parameter Name="end" Type="Gtk.TextIter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="start">
          A <see cref="T:Gtk.TextIter" /> object to store the location
          of the beginning of the buffer.
        </param>
        <param name="end">
          A <see cref="T:Gtk.TextIter" /> object to store the location
          of the end of the buffer.
        </param>
        <summary>
          Retrieves the first and last iterators in the buffer, i.e. the entire buffer.
        </summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtChildAnchor">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtChildAnchor (Gtk.TextChildAnchor anchor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtChildAnchor(class Gtk.TextChildAnchor anchor) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anchor" Type="Gtk.TextChildAnchor" />
      </Parameters>
      <Docs>
        <param name="anchor">A <see cref="T:Gtk.TextChildAnchor" /> at the current buffer.</param>
        <summary>Gets the location of the specific anchor.</summary>
        <returns>The location at <paramref name="anchor" />.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLine">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtLine (int line_number);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtLine(int32 line_number) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="line_number" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="line_number">The specified line number.</param>
        <summary>Gets the location of a particular line.</summary>
        <returns>The location at the beginning fo the line as specified by <paramref name="line_number" />.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLineIndex">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtLineIndex (int line_number, int byte_index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtLineIndex(int32 line_number, int32 byte_index) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="line_number" Type="System.Int32" />
        <Parameter Name="byte_index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="line_number">A line number for the current buffer, counting from 0.</param>
        <param name="byte_index">The byte index from start of line.</param>
        <summary>Obtains an iterator pointing to <paramref name="byte_index" /> within the given line.</summary>
        <returns>The location as specified by <paramref name="line_number" /> and <paramref name="byte_index" />.</returns>
        <remarks>
          <para>
            <paramref name="byte_index" /> must be the start of a
            UTF-8 character, and must not be beyond the end of the
            line. Note bytes, not characters; UTF-8 may encode one
            character as multiple bytes.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIterAtLineOffset">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtLineOffset (int line_number, int char_offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtLineOffset(int32 line_number, int32 char_offset) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="line_number" Type="System.Int32" />
        <Parameter Name="char_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="line_number">a <see cref="T:System.Int32" /></param>
        <param name="char_offset">a <see cref="T:System.Int32" /></param>
        <summary>Gets the location of a specific point.</summary>
        <returns>The location at the location specified by <paramref name="line_number" /> and <paramref name="char_offset" />.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtMark">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtMark (Gtk.TextMark mark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtMark(class Gtk.TextMark mark) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <param name="mark">The specified mark.</param>
        <summary>Gets the location of the specified mark.</summary>
        <returns>The location of <paramref name="mark" />.</returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetIterAtOffset">
      <MemberSignature Language="C#" Value="public Gtk.TextIter GetIterAtOffset (int char_offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Gtk.TextIter GetIterAtOffset(int32 char_offset) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="char_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="char_offset">The requested character offset</param>
        <summary>Returns the location at a particular character offset</summary>
        <returns>The location at <paramref name="char_offset" /></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark GetMark (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gtk.TextMark GetMark(string name) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">the name of a mark</param>
        <summary>
          Returns the mark named name in buffer buffer, or <see langword="null" /> if no such mark exists in the buffer.
        </summary>
        <returns>
          Returns the mark named name in buffer buffer, or <see langword="null" /> if no such mark exists in the buffer.
        </returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GetSelectionBounds">
      <MemberSignature Language="C#" Value="public bool GetSelectionBounds (out Gtk.TextIter start, out Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetSelectionBounds(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter&amp;" RefType="out" />
        <Parameter Name="end" Type="Gtk.TextIter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="start">the location of the beginning of the selection</param>
        <param name="end">the location of the end of the selection</param>
        <summary>Returns <see langword="true" /> if some text is selected</summary>
        <returns>Returns <see langword="true" /> if the selection has nonzero length</returns>
        <remarks>
          <para>
            Returns <see langword="true" /> if some text is selected;
            and sets the bounds of the selection in <paramref name="start" /> and <paramref name="end" /> (if
            the selection has length 0, then start and end are filled
            in with the same value). <paramref name="start" /> and <paramref name="end" /> will be in
            ascending order. If <paramref name="start" /> and <paramref name="end" /> are <see langword="null" />, then they are
            not filled in, but the return value still indicates
            whether text is selected.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSlice">
      <MemberSignature Language="C#" Value="public string GetSlice (Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetSlice(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end, bool include_hidden_chars) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="include_hidden_chars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="start">the start of a range</param>
        <param name="end">the end of the range</param>
        <param name="include_hidden_chars">whether to include invisible text</param>
        <summary>
          Returns the text from <paramref name="start" /> to <paramref name=",end" />.
        </summary>
        <returns>
          a string containing the text from <paramref name="start" />
          to <paramref name="end" /></returns>
        <remarks>
          <para>
            Returns the text in the range from <paramref name="start" /> to <paramref name="end" />. Excludes undisplayed text
            (text marked with tags that set the invisibility
            attribute) if <paramref name="include_hidden_chars" /> is
            <see langword="false" />. The returned string includes a
            0xFFFC character whenever the buffer contains embedded
            images, so byte and character indexes into the returned
            string do correspond to byte and character indexes into
            the buffer. Contrast with <see cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)" />. Note that 0xFFFC can occur in normal text as well, so
            it is not a reliable indicator that a pixbuf or widget is
            in the buffer.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (Gtk.TextIter start, Gtk.TextIter end, bool include_hidden_chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end, bool include_hidden_chars) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="include_hidden_chars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="start">the beginning of the specified range</param>
        <param name="end">the end of the specified range</param>
        <param name="include_hidden_chars">whether to include invisible text</param>
        <summary>Returns the text from a specified range</summary>
        <returns>a string containing the text from the specified range</returns>
        <remarks>
          <para>
            Returns the text in the range specified by <paramref name="start" /> and <paramref name="end" />. Excludes
            undisplayed text (text marked with tags that set the
            invisibility attribute) if <paramref name="include_hidden_chars" /> is <see langword="false" />. Does not include characters
            representing embedded images, so byte and character
            indexes into the returned string do not correspond to byte
            and character indexes into the buffer.
          </para>
          <para>
            Contrast this with <see cref="M:Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,System.Boolean)" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GType">
      <MemberSignature Language="C#" Value="public static GLib.GType GType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype GLib.GType GType" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>GLib.GType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>GType Property.</summary>
        <value>a <see cref="T:GLib.GType" /></value>
        <remarks>Returns the native <see cref="T:GLib.GType" /> value for <see cref="T:Gtk.TextBuffer" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasSelection">
      <MemberSignature Language="C#" Value="public bool HasSelection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasSelection" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("has-selection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates presence of a selection.</summary>
        <value>if <see langword="true" />, there is text selected currently.</value>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (Gtk.TextIter iter, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Insert(valuetype Gtk.TextIter iter, string text) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by 'ref TextIter iter' overload")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iter">To be added.</param>
        <param name="text">To be added.</param>
        <summary>Inserts text.</summary>
        <remarks>The overload is obsolete, replace by the ref TextIter overload.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (ref Gtk.TextIter iter, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Insert(valuetype Gtk.TextIter iter, string text) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iter">
          The location for <paramref name="text" /> to be
          inserted
        </param>
        <param name="text">The text to be inserted</param>
        <summary>Insert text at a specific point</summary>
        <remarks />
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertAtCursor">
      <MemberSignature Language="C#" Value="public void InsertAtCursor (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAtCursor(string text) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to be inserted</param>
        <summary>Insert text into the current cursor position</summary>
        <remarks>
          <para>
            The <see cref="E:Gtk.TextBuffer.InsertText" /> event is
            raised when a call to this method is made.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertChildAnchor">
      <MemberSignature Language="C#" Value="public void InsertChildAnchor (ref Gtk.TextIter iter, Gtk.TextChildAnchor anchor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertChildAnchor(valuetype Gtk.TextIter iter, class Gtk.TextChildAnchor anchor) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="anchor" Type="Gtk.TextChildAnchor" />
      </Parameters>
      <Docs>
        <param name="iter">location to insert the anchor</param>
        <param name="anchor">a <see cref="T:Gtk.TextChildAnchor" />.</param>
        <summary>Inserts a child widget anchor into the text buffer.</summary>
        <remarks>
          <para>
            Inserts a child widget anchor into the text buffer at <paramref name="iter" />. The anchor will be counted as one
            character in character counts, and when obtaining the
            buffer contents as a string, will be represented by the
            Unicode "object replacement character" 0xFFFC. Note that
            the "slice" variants for obtaining portions of the buffer
            as a string include this character for pixbufs, but the
            "text" variants do not. e.g. see <see cref="M:Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,System.Boolean)" /> and <see cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)" />). Consider <see cref="M:Gtk.TextBuffer.CreateChildAnchor(Gtk.TextIter)" /> as a
            more convenient alternative to this function. The buffer
            will add a reference to the anchor, so you can unref it
            after insertion.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertInteractive">
      <MemberSignature Language="C#" Value="public bool InsertInteractive (ref Gtk.TextIter iter, string text, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertInteractive(valuetype Gtk.TextIter iter, string text, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="iter">a location in the buffer</param>
        <param name="text">the text to be inserted</param>
        <param name="default_editable">the default editability of buffer</param>
        <summary>
          Insert text if the cursor is at an editable point in
          the buffer
        </summary>
        <returns>whether text was actually inserted</returns>
        <remarks>
          <para>
            Similar to <see cref="M:Gtk.TextBuffer.Insert(Gtk.TextIter,System.String)" />, but the insertion will not occur if <paramref name="iter" /> is at a non-editable location in the
            buffer. Usually you want to prevent insertions at
            ineditable locations if the insertion results from a user
            action (is interactive).
          </para>
          <para>
            <paramref name="default_editable" /> indicates the editability of text that
            does not have a tag affecting editability applied to
            it. Typically the result of <see cref="P:Gtk.TextView.Editable" />
            is appropriate here.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertInteractiveAtCursor">
      <MemberSignature Language="C#" Value="public bool InsertInteractiveAtCursor (string text, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertInteractiveAtCursor(string text, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">The text to be inserted</param>
        <param name="default_editable">The default editability of the buffer</param>
        <summary>Insert text at cursor position if the location is editable</summary>
        <returns>Whether or not <paramref name="text" /> was inserted</returns>
        <remarks>
          See <see cref="M:Gtk.TextBuffer.InsertInteractive(Gtk.TextIter,System.String,System.Boolean)" /> for more details.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertMark">
      <MemberSignature Language="C#" Value="public Gtk.TextMark InsertMark { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gtk.TextMark InsertMark" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the mark that represents the cursor (insertion point).</summary>
        <value>The mark of the insert point.</value>
        <remarks>
          <para>
            This is equivelant to calling <see cref="M:Gtk.TextBuffer.GetMark(System.String)" /> for the
            mark named "insert". 
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertPixbuf">
      <MemberSignature Language="C#" Value="public void InsertPixbuf (ref Gtk.TextIter iter, Gdk.Pixbuf pixbuf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertPixbuf(valuetype Gtk.TextIter iter, class Gdk.Pixbuf pixbuf) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="pixbuf" Type="Gdk.Pixbuf" />
      </Parameters>
      <Docs>
        <param name="iter">The location to insert the image</param>
        <param name="pixbuf">The image to be inserted</param>
        <summary>
          Inserts an image into the text buffer at <paramref name="iter" />.
        </summary>
        <remarks>
          <para>
            Inserts an image into the text buffer at <paramref name="iter" />. The image will be counted as one character in character counts, and
            when obtaining the buffer contents as a string, will be
            represented by the Unicode "object replacement character"
            0xFFFC. Note that the "slice" variants for obtaining
            portions of the buffer as a string include this character
            for pixbufs, but the "text" variants do not. e.g. see
            <see cref="M:Gtk.TextBuffer.GetSlice(Gtk.TextIter,Gtk.TextIter,System.Boolean)" /> and <see cref="M:Gtk.TextBuffer.GetText(Gtk.TextIter,Gtk.TextIter,System.Boolean)" />.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(valuetype Gtk.TextIter iter, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by 'ref TextIter iter' overload")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="iter">To be added.</param>
        <param name="start">To be added.</param>
        <param name="end">To be added.</param>
        <summary>Inserts a range of text.</summary>
        <remarks>This overload is obsolete, replaced by ref TextIter overloads since the iters passed in are updated by the caller.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (ref Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(valuetype Gtk.TextIter iter, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="iter">a position in buffer</param>
        <param name="start">
          a position in the source <see cref="T:Gtk.TextBuffer" /></param>
        <param name="end">
          a position in the source <see cref="T:Gtk.TextBuffer" /></param>
        <summary>
          Copies text, tags, and pixbufs between <paramref name="start" />
          and <paramref name="end" /> and inserts the copy at <paramref name="iter" />.
        </summary>
        <remarks>
          <para>
            Copies text, tags, and pixbufs between <paramref name="start" /> and <paramref name="end" /> (the
            order does not matter) and inserts the
            copy at <paramref name="iter" />. Used instead of simply getting/inserting
            text because it preserves images and tags. If <paramref name="start" /> and
            <paramref name="end" /> are in a different buffer from buffer, the two buffers
            must share the same tag table.
          </para>
          <para>
            This method is implemented with the <see cref="E:Gtk.TextBuffer.InsertText" /> and <see cref="E:Gtk.TextBuffer.ApplyTag" /> events.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertRangeInteractive">
      <MemberSignature Language="C#" Value="public bool InsertRangeInteractive (ref Gtk.TextIter iter, Gtk.TextIter start, Gtk.TextIter end, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertRangeInteractive(valuetype Gtk.TextIter iter, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="iter">a position in buffer</param>
        <param name="start">
          a position in the source <see cref="Gtk.TextBuffer" /></param>
        <param name="end">
          a position in the source <see cref="Gtk.TextBuffer" /></param>
        <param name="default_editable">
          whether the text is editable at <paramref name="iter" /> if no tags enclosing
          iter affect editability
        </param>
        <summary>
          Same as <see cref="M:Gtk.TextBuffer.InsertRange(Gtk.TextIter,Gtk.TextIter,Gtk.TextIter)" />, but does nothing if the insertion point is not editable.
        </summary>
        <returns>
          <see langword="true" /> if an insertion was possible at <paramref name="iter" /></returns>
        <remarks>
          <para>
            Same as <see cref="M:Gtk.TextBuffer.InsertRange(Gtk.TextIter,Gtk.TextIter,Gtk.TextIter)" />, but does nothing if the insertion point is not
            editable.
          </para>
          <para>
            The <paramref name="default_editable" /> parameter
            indicates whether the text is editable at <paramref name="iter" /> if no tags
            enclosing iter affect editability. Typically the result of
            <see cref="P:Gtk.TextView.Editable" /> is appropriate here.
          </para>
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertText">
      <MemberSignature Language="C#" Value="public event Gtk.InsertTextHandler InsertText;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.InsertTextHandler InsertText" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("insert-text")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.InsertTextHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when text is inserted into the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="InsertWithTags">
      <MemberSignature Language="C#" Value="public void InsertWithTags (Gtk.TextIter iter, string text, Gtk.TextTag[] tags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertWithTags(valuetype Gtk.TextIter iter, string text, class Gtk.TextTag[] tags) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by 'ref TextIter iter' overload")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="tags" Type="Gtk.TextTag[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="iter">To be added.</param>
        <param name="text">To be added.</param>
        <param name="tags">To be added.</param>
        <summary>Inserts text with tag information.</summary>
        <remarks>The overload is obsolete, replace by the ref TextIter overload.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertWithTags">
      <MemberSignature Language="C#" Value="public void InsertWithTags (ref Gtk.TextIter iter, string text, Gtk.TextTag[] tags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertWithTags(valuetype Gtk.TextIter iter, string text, class Gtk.TextTag[] tags) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="tags" Type="Gtk.TextTag[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="iter">location to insert the text</param>
        <param name="text">text to insert</param>
        <param name="tags">tags to apply to <paramref name="text" /></param>
        <summary>Inserts <paramref name="text" /> into buffer at <paramref name="iter" />, applying the list of <paramref name="tags" /> to the newly-inserted text.</summary>
        <remarks>Equivalent to calling <see cref="M:Gtk.TextBuffer.Insert()" />, then <see cref="Gtk.TextBuffer.ApplyTag()" /> on the inserted text; It is just a convenience function.</remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="InsertWithTagsByName">
      <MemberSignature Language="C#" Value="public void InsertWithTagsByName (ref Gtk.TextIter iter, string text, string[] tagnames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertWithTagsByName(valuetype Gtk.TextIter iter, string text, string[] tagnames) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="tagnames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="iter">location to insert the text</param>
        <param name="text">text to insert</param>
        <param name="tagnames">names of the tags to apply to <paramref name="text" /></param>
        <summary>Inserts <paramref name="text" /> into buffer at <paramref name="iter" />, applying the list of tags with names <paramref name="tagnamess" /> to the newly-inserted text.</summary>
        <remarks>Equivalent to calling <see cref="M:Gtk.TextBuffer.Insert()" />, then <see cref="Gtk.TextBuffer.ApplyTag()" /> on the inserted text; It is just a convenience function.</remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="LineCount">
      <MemberSignature Language="C#" Value="public int LineCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineCount" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the number of lines in the buffer.</summary>
        <value>The number of lines in the buffer</value>
        <remarks>
          <para>
            The results of this method is cached, so this is very fast.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDeleted">
      <MemberSignature Language="C#" Value="public event Gtk.MarkDeletedHandler MarkDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.MarkDeletedHandler MarkDeleted" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("mark-deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.MarkDeletedHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a mark has been deleted from the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="MarkSet">
      <MemberSignature Language="C#" Value="public event Gtk.MarkSetHandler MarkSet;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.MarkSetHandler MarkSet" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("mark-set")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.MarkSetHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a mark is set in the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Modified">
      <MemberSignature Language="C#" Value="public bool Modified { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modified" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>Whether or not the buffer has been modified</summary>
        <value>
          <see langword="true" /> if the buffer has
          been modified, <see langword="false" /> otherwise.
        </value>
        <remarks>
          <para>
            Whenever the buffer is saved to disk, set this property to
            <see langword="false" />. When the buffer is modified, it
            will automatically toggled to <see langword="true" />.
          </para>
          <para>
            Whenever this property is changed, the <see cref="E:Gtk.TextBuffer.ModifiedChanged" /> event is raised.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifiedChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ModifiedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ModifiedChanged" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("modified-changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when the Modified status of the buffer is changed.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="MoveMark">
      <MemberSignature Language="C#" Value="public void MoveMark (Gtk.TextMark mark, Gtk.TextIter wh3r3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveMark(class Gtk.TextMark mark, valuetype Gtk.TextIter wh3r3) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
        <Parameter Name="wh3r3" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="mark">a <see cref="T:Gtk.TextMark" />.</param>
        <param name="wh3r3">To be added.</param>
        <summary>Moves mark to the new location <paramref name="where" />.</summary>
        <remarks>
          <para>
            Moves mark to the new location where. Fires the <see cref="E:Gtk.TextBuffer.MarkSet" /> event as notification of the move.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveMark">
      <MemberSignature Language="C#" Value="public void MoveMark (string name, Gtk.TextIter wh3r3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveMark(string name, valuetype Gtk.TextIter wh3r3) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="wh3r3" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="name">the name of the mark</param>
        <param name="wh3r3">To be added.</param>
        <summary>
          Moves the mark named <paramref name="name" /> (which must
          exist) to location <paramref name="where" />.
        </summary>
        <remarks>
          <para>It is possible to use built-in marks to implement a "Select All" method on a buffer (e.g. <see cref="M:Gtk.TextView.Buffer" />).</para>
          <para>
            <example>
              <code lang="C#">
	private void SelectAll (TextBuffer buffer)
	{
		buffer.MoveMark ("insert", buffer.StartIter);
		buffer.MoveMark ("selection_bound", buffer.EndIter);
	}
  </code>
            </example>
          </para>
          <para>See <see cref="M:Gtk.TextBuffer.MoveMark(Gtk.TextMark,Gtk.TextIter)" /> for more details.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideChanged", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.Changed" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.Changed" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChildAnchorInserted">
      <MemberSignature Language="C#" Value="protected virtual void OnChildAnchorInserted (Gtk.TextIter iter, Gtk.TextChildAnchor anchor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildAnchorInserted(valuetype Gtk.TextIter iter, class Gtk.TextChildAnchor anchor) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideChildAnchorInserted", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="anchor" Type="Gtk.TextChildAnchor" />
      </Parameters>
      <Docs>
        <param name="iter">To be added.</param>
        <param name="anchor">a <see cref="T:Gtk.TextChildAnchor" /></param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.ChildAnchorInserted" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.ChildAnchorInserted" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeleteRange">
      <MemberSignature Language="C#" Value="protected virtual void OnDeleteRange (Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeleteRange(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideDeleteRange", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="start">a <see cref="T:Gtk.TextIter" /></param>
        <param name="end">a <see cref="T:Gtk.TextIter" /></param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.DeleteRange" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.DeleteRange" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInsertText">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertText (Gtk.TextIter pos, string new_text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertText(valuetype Gtk.TextIter pos, string new_text) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideInsertText", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pos" Type="Gtk.TextIter" />
        <Parameter Name="new_text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pos">a <see cref="T:Gtk.TextIter" /></param>
        <param name="new_text">To be added.</param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.InsertText" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.InsertText" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMarkDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnMarkDeleted (Gtk.TextMark mark);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarkDeleted(class Gtk.TextMark mark) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideMarkDeleted", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <param name="mark">a <see cref="T:Gtk.TextMark" /></param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.MarkDeleted" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.MarkDeleted" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMarkSet">
      <MemberSignature Language="C#" Value="protected virtual void OnMarkSet (Gtk.TextIter location, Gtk.TextMark mark);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarkSet(valuetype Gtk.TextIter location, class Gtk.TextMark mark) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideMarkSet", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="Gtk.TextIter" />
        <Parameter Name="mark" Type="Gtk.TextMark" />
      </Parameters>
      <Docs>
        <param name="location">a <see cref="T:Gtk.TextIter" /></param>
        <param name="mark">a <see cref="T:Gtk.TextMark" /></param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.MarkSet" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.MarkSet" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnModifiedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnModifiedChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnModifiedChanged() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideModifiedChanged", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.ModifiedChanged" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.ModifiedChanged" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPasteDone">
      <MemberSignature Language="C#" Value="protected virtual void OnPasteDone (Gtk.Clipboard clipboard);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPasteDone(class Gtk.Clipboard clipboard) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverridePasteDone", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <param name="clipboard">To be added.</param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.PasteDone" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.PasteDone" /> event.</remarks>
        <since version="Gtk# 3.0" />
      </Docs>
    </Member>
    <Member MemberName="OnPixbufInserted">
      <MemberSignature Language="C#" Value="protected virtual void OnPixbufInserted (Gtk.TextIter iter, Gdk.Pixbuf pixbuf);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPixbufInserted(valuetype Gtk.TextIter iter, class Gdk.Pixbuf pixbuf) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverridePixbufInserted", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iter" Type="Gtk.TextIter" />
        <Parameter Name="pixbuf" Type="Gdk.Pixbuf" />
      </Parameters>
      <Docs>
        <param name="iter">To be added.</param>
        <param name="pixbuf">a <see cref="T:Gdk.Pixbuf" /></param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.PixbufInserted" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.PixbufInserted" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTagApplied">
      <MemberSignature Language="C#" Value="protected virtual void OnTagApplied (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTagApplied(class Gtk.TextTag tag, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideTagApplied", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="tag">a <see cref="T:Gtk.TextTag" /></param>
        <param name="start">To be added.</param>
        <param name="end">To be added.</param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.TagApplied" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.TagApplied" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTagRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnTagRemoved (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTagRemoved(class Gtk.TextTag tag, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideTagRemoved", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="tag">a <see cref="T:Gtk.TextTag" /></param>
        <param name="start">To be added.</param>
        <param name="end">To be added.</param>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.TagRemoved" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.TagRemoved" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUserActionBegun">
      <MemberSignature Language="C#" Value="protected virtual void OnUserActionBegun ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUserActionBegun() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideUserActionBegun", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.UserActionBegun" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.UserActionBegun" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUserActionEnded">
      <MemberSignature Language="C#" Value="protected virtual void OnUserActionEnded ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUserActionEnded() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.DefaultSignalHandler(ConnectionMethod="OverrideUserActionEnded", Type=typeof(Gtk.TextBuffer))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Default handler for the <see cref="M:Gtk.TextBuffer.UserActionEnded" /> event.</summary>
        <remarks>Override this method in a subclass to provide a default handler for the <see cref="M:Gtk.TextBuffer.UserActionEnded" /> event.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PasteClipboard">
      <MemberSignature Language="C#" Value="public void PasteClipboard (Gtk.Clipboard clipboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PasteClipboard(class Gtk.Clipboard clipboard) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <param name="clipboard">a <see cref="T:Gtk.Clipboard" /></param>
        <summary>Pastes the contents of a clipboard at the insertion point.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="PasteClipboard">
      <MemberSignature Language="C#" Value="public void PasteClipboard (Gtk.Clipboard clipboard, ref Gtk.TextIter override_location, bool default_editable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PasteClipboard(class Gtk.Clipboard clipboard, valuetype Gtk.TextIter override_location, bool default_editable) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
        <Parameter Name="override_location" Type="Gtk.TextIter&amp;" RefType="ref" />
        <Parameter Name="default_editable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clipboard">the <see cref="T:Gtk.Clipboard" /> to paste from</param>
        <param name="override_location">
          the location to insert pasted text, or <see langword="null" /> for at the cursor
        </param>
        <param name="default_editable">
          whether the buffer is editable by default
        </param>
        <summary>
          Pastes the contents of a clipboard at the insertion point,
        or at <paramref name="override_location" />.
        </summary>
        <remarks>
          Pastes the contents of a clipboard at the insertion point,
          or at <paramref name="override_location" />. (Note: pasting
          is asynchronous, that is, we will ask for the paste data and
          return, and at some point later after the main loop runs,
          the paste data will be inserted.)
        </remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="PasteDone">
      <MemberSignature Language="C#" Value="public event Gtk.PasteDoneHandler PasteDone;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.PasteDoneHandler PasteDone" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("paste-done")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.PasteDoneHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version="Gtk# 3.0" />
      </Docs>
    </Member>
    <Member MemberName="PasteTargetList">
      <MemberSignature Language="C#" Value="public Gtk.TargetList PasteTargetList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gtk.TargetList PasteTargetList" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("paste-target-list")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.TargetList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtains the paste TargetList.</summary>
        <value>a <see cref="Gtk.TargetList" />.</value>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="PixbufInserted">
      <MemberSignature Language="C#" Value="public event Gtk.PixbufInsertedHandler PixbufInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.PixbufInsertedHandler PixbufInserted" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("insert-pixbuf")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.PixbufInsertedHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a Pixbuf is inserted into the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="PlaceCursor">
      <MemberSignature Language="C#" Value="public void PlaceCursor (Gtk.TextIter wh3r3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PlaceCursor(valuetype Gtk.TextIter wh3r3) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wh3r3" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="wh3r3">where to put the cursor</param>
        <summary>Moves the "insert" and "selection_bound" marks simultaneously.</summary>
        <remarks>
          <para>
            This function moves the "insert" and "selection_bound"
            marks simultaneously. If you move them to the same place
            in two steps with <see cref="M:Gtk.TextBuffer.MoveMarkGtk.TextMark,Gtk.TextIter)" />,
            you will temporarily select a region in between their old
            and new locations, which can be pretty inefficient since
            the temporarily-selected region will force stuff to be
            recalculated. This function moves them as a unit, which
            can be optimized.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterDeserializeFormat">
      <MemberSignature Language="C#" Value="public Gdk.Atom RegisterDeserializeFormat (string mime_type, Gtk.TextBufferDeserializeFunc function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gdk.Atom RegisterDeserializeFormat(string mime_type, class Gtk.TextBufferDeserializeFunc function) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mime_type" Type="System.String" />
        <Parameter Name="function" Type="Gtk.TextBufferDeserializeFunc" />
      </Parameters>
      <Docs>
        <param name="mime_type">a MIME type target.</param>
        <param name="function">Serialization formatter for the specified <paramref name="mime_type" />.</param>
        <summary>Registers a deserialization handler for a given MIME type.</summary>
        <returns>an atom representing the MIME type.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDeserializeTagset">
      <MemberSignature Language="C#" Value="public Gdk.Atom RegisterDeserializeTagset (string tagset_name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gdk.Atom RegisterDeserializeTagset(string tagset_name) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagset_name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagset_name">name of tagset, or <see langword="null" />.</param>
        <summary>Registers TextBuffer's internal serialization format.</summary>
        <returns>The newly registered format's mime type.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="RegisterSerializeFormat">
      <MemberSignature Language="C#" Value="public Gdk.Atom RegisterSerializeFormat (string mime_type, Gtk.TextBufferSerializeFunc function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gdk.Atom RegisterSerializeFormat(string mime_type, class Gtk.TextBufferSerializeFunc function) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mime_type" Type="System.String" />
        <Parameter Name="function" Type="Gtk.TextBufferSerializeFunc" />
      </Parameters>
      <Docs>
        <param name="mime_type">A MIME type target.</param>
        <param name="function">Serialization formatter for the specified <paramref name="mime_type" />.</param>
        <summary>Registers a serialization formatter for a given MIME type.</summary>
        <returns />
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="RegisterSerializeTagset">
      <MemberSignature Language="C#" Value="public Gdk.Atom RegisterSerializeTagset (string tagset_name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Gdk.Atom RegisterSerializeTagset(string tagset_name) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagset_name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagset_name">name of tagset, or <see langword="null" />.</param>
        <summary>Registers TextBuffer's internal serialization format.</summary>
        <returns>The newly registered format's mime type.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAllTags">
      <MemberSignature Language="C#" Value="public void RemoveAllTags (Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAllTags(valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="start">The beginning of the range</param>
        <param name="end">The end of the range</param>
        <summary>
          Removes all tags in the range between <paramref name="start" /> and <paramref name="end" />.
        </summary>
        <remarks>
          <para>
            Removes all tags in the range between start and end. Be
            careful with this function; it could remove tags added in
            code unrelated to the code you are currently writing. That
            is, calling this method is probably a bad idea if you have
            two or more unrelated code sections that add tags.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSelectionClipboard">
      <MemberSignature Language="C#" Value="public void RemoveSelectionClipboard (Gtk.Clipboard clipboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveSelectionClipboard(class Gtk.Clipboard clipboard) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipboard" Type="Gtk.Clipboard" />
      </Parameters>
      <Docs>
        <param name="clipboard">an object of type <see cref="T:Gtk.Clipboard" /></param>
        <summary>Removes a <see cref="T:Gtk.Clipboard" /> added with <see cref="M:Gtk.TextBuffer.AddSelectionClipboard()" />.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="RemoveTag">
      <MemberSignature Language="C#" Value="public void RemoveTag (Gtk.TextTag tag, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveTag(class Gtk.TextTag tag, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="Gtk.TextTag" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="tag">the <see cref="T:Gtk.TextTag" /> to remove</param>
        <param name="start">the beginning of the range</param>
        <param name="end">the end of the range</param>
        <summary>
          Fires the <see cref="E:Gtk.TextBuffer.RemoveTag" /> events
          and removes all occurrences of <paramref name="tag" /> from
          the given range
        </summary>
        <remarks>
          <para>
            Fires the <see cref="E:Gtk.TextBuffer.RemoveTag" />
            event. The default handler for the signal removes all
            occurrences of tag from the given range. <paramref name="start" /> and <paramref name="end" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTag">
      <MemberSignature Language="C#" Value="public void RemoveTag (string name, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveTag(string name, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="name">the name of the tag</param>
        <param name="start">the beginning of the buffer to be untagged</param>
        <param name="end">the end of the buffer to be untagged</param>
        <summary>
          Calls <see cref="M:Gtk.TextTagTable.Lookup(System.String)" /> on the buffer's tag table to get a <see cref="T:Gtk.TextTag" />, then calls
          <see cref="M:Gtk.TextBuffer.RemoveTag(Gtk.TextTag,Gtk.TextIter,Gtk.TextIter)" /></summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="SelectionBound">
      <MemberSignature Language="C#" Value="public Gtk.TextMark SelectionBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gtk.TextMark SelectionBound" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextMark</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the mark that represents the selection bound.</summary>
        <value>a <see cref="T:Gtk.TextMark" /></value>
        <remarks>
          <para>
            Returns the mark that represents the selection
            bound. Equivalent to calling <see cref="Gtk.TextBuffer.GetMark(System.String)" /> to
            get the mark named "selection_bound", but very slightly
            more efficient, and involves less typing.
          </para>
          <para>
            The currently-selected text in buffer is the region
            between the "selection_bound" and "insert" marks. If
            "selection_bound" and "insert" are in the same place, then
            there is no current selection. <see cref="M:Gtk.TextBuffer.GetSelectionBounds(Gtk.TextIter,Gtk.TextIter)" /> is another convenient function for handling the
            selection, if you just want to know whether there is a
            selection and what its bounds are.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectRange">
      <MemberSignature Language="C#" Value="public void SelectRange (Gtk.TextIter ins, Gtk.TextIter bound);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectRange(valuetype Gtk.TextIter ins, valuetype Gtk.TextIter bound) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ins" Type="Gtk.TextIter" />
        <Parameter Name="bound" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="ins">a <see cref="T:Gtk.TextIter" /></param>
        <param name="bound">a <see cref="T:Gtk.TextIter" /></param>
        <summary> This function moves the <paramref name="insert" /> and 
	  <paramref name="selection_bound" /> marks simultaneously.  
	</summary>
        <remarks>
	  If you move them in two steps
	  with <see cref="M:Gtk.TextBuffer.MoveMark" />, you will temporarily select a
	  region in between their old and new locations, which can be pretty
	  inefficient since the temporarily-selected region will force stuff
	  to be recalculated. This function moves them as a unit, which can
	  be optimized.
	</remarks>
        <since version="Gtk# 2.4" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public byte[] Serialize (Gtk.TextBuffer content_buffer, Gdk.Atom format, Gtk.TextIter start, Gtk.TextIter end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Serialize(class Gtk.TextBuffer content_buffer, class Gdk.Atom format, valuetype Gtk.TextIter start, valuetype Gtk.TextIter end) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content_buffer" Type="Gtk.TextBuffer" />
        <Parameter Name="format" Type="Gdk.Atom" />
        <Parameter Name="start" Type="Gtk.TextIter" />
        <Parameter Name="end" Type="Gtk.TextIter" />
      </Parameters>
      <Docs>
        <param name="content_buffer">buffer containing text to serialize.</param>
        <param name="format">MIME type format.</param>
        <param name="start">beginning of desired text.</param>
        <param name="end">end of desired text.</param>
        <summary>Serializes a range of text.</summary>
        <returns>the serialized data stream.</returns>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="SerializeFormats">
      <MemberSignature Language="C#" Value="public Gdk.Atom[] SerializeFormats { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gdk.Atom[] SerializeFormats" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gdk.Atom[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The supported MIME type formats for Serialization.</summary>
        <value>an array of MIME type Atoms.</value>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="SetText">
      <MemberSignature Language="C#" Value="public void SetText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetText(string text) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the TextBuffer.Text property's setter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The new contents of the buffer</param>
        <summary>Set the contents of the buffer</summary>
        <remarks>
          <para>
            This is equivelant to using the setter of the
            <see cref="P:Gtk.TextBuffer.Text" /> property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartIter">
      <MemberSignature Language="C#" Value="public Gtk.TextIter StartIter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Gtk.TextIter StartIter" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Gtk.TextIter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The location of the beginning of the buffer</summary>
        <value>The location of the beginning of the buffer</value>
        <remarks>
          <para>
            This is the equivelant to calling <see cref="M:Gtk.TextBuffer.GetIterAtOffset(System.Int32)" /> to get the iter at character offset 0.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagApplied">
      <MemberSignature Language="C#" Value="public event Gtk.TagAppliedHandler TagApplied;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.TagAppliedHandler TagApplied" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("apply-tag")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.TagAppliedHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a tag is applied to the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="TagRemoved">
      <MemberSignature Language="C#" Value="public event Gtk.TagRemovedHandler TagRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class Gtk.TagRemovedHandler TagRemoved" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("remove-tag")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.TagRemovedHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a tag is removed from the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="TagTable">
      <MemberSignature Language="C#" Value="public Gtk.TextTagTable TagTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Gtk.TextTagTable TagTable" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("tag-table")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Gtk.TextTagTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The tag table of the current buffer</summary>
        <value>The current <see cref="T:Gtk.TextTagTable" /> of the buffer</value>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Property("text")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <summary>The complete contents of the buffer</summary>
        <value>The contents of the current buffer</value>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="UnregisterDeserializeFormat">
      <MemberSignature Language="C#" Value="public void UnregisterDeserializeFormat (Gdk.Atom format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterDeserializeFormat(class Gdk.Atom format) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="Gdk.Atom" />
      </Parameters>
      <Docs>
        <param name="format">format Atom for a MIME type.</param>
        <summary>Removes a registered MIME type handler from the buffer.</summary>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterSerializeFormat">
      <MemberSignature Language="C#" Value="public void UnregisterSerializeFormat (Gdk.Atom format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterSerializeFormat(class Gdk.Atom format) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="Gdk.Atom" />
      </Parameters>
      <Docs>
        <param name="format">format to unregister.</param>
        <summary>Removes a Serialization format from the registry.</summary>
        <remarks />
        <since version="Gtk# 2.10" />
      </Docs>
    </Member>
    <Member MemberName="UserActionBegun">
      <MemberSignature Language="C#" Value="public event EventHandler UserActionBegun;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler UserActionBegun" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("begin-user-action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a UserAction is begun on the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="UserActionEnded">
      <MemberSignature Language="C#" Value="public event EventHandler UserActionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler UserActionEnded" />
      <MemberType>Event</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>GLib.Signal("end-user-action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emitted when a UserAction ends on the buffer.</summary>
        <remarks />
      </Docs>
    </Member>
  </Members>
</Type>
